#!/usr/bin/env bash

# Context-Kit Service Startup Script
# Starts all context-kit services in the correct order with health checks

# Enable error handling - compatible with both bash and zsh
# Note: Selective error handling to avoid conflicts with terminal logging
set -e
# set -u  # Disabled due to conflicts with terminal logging sourcing
if [[ -n "${BASH_VERSION:-}" ]]; then
    set -o pipefail
fi

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly NC='\033[0m' # No Color

# Script configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
readonly PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
readonly CONTEXT_KIT_DIR="${PROJECT_ROOT}/.context-kit"
readonly LOG_DIR="${CONTEXT_KIT_DIR}/logs"
readonly PID_DIR="${CONTEXT_KIT_DIR}/.pids"

# Service configuration
# Service configuration - compatible with both bash and zsh
if [[ -n "${BASH_VERSION:-}" ]]; then
    declare -A SERVICES
    declare -A SERVICE_DEPS
else
    # zsh associative arrays
    typeset -A SERVICES
    typeset -A SERVICE_DEPS
fi

SERVICES["knowledge-graph"]="42003"
SERVICES["dashboard"]="42001"

SERVICE_DEPS["dashboard"]="knowledge-graph"

# Global variables
CLEANUP_ON_EXIT=true
VERBOSE=false
DRY_RUN=false
FORCE_RESTART=false

# Logging functions
log() {
    echo -e "${WHITE}[$(date +'%H:%M:%S')]${NC} $*"
}

log_info() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')] INFO:${NC} $*"
}

log_success() {
    echo -e "${GREEN}[$(date +'%H:%M:%S')] SUCCESS:${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[$(date +'%H:%M:%S')] WARNING:${NC} $*"
}

log_error() {
    echo -e "${RED}[$(date +'%H:%M:%S')] ERROR:${NC} $*" >&2
}

log_debug() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${PURPLE}[$(date +'%H:%M:%S')] DEBUG:${NC} $*"
    fi
}

# Help function
show_help() {
    cat << EOF
Context-Kit Service Startup Script

USAGE:
    $0 [OPTIONS] [SERVICES...]

DESCRIPTION:
    Starts all context-kit services in the correct order with health checks.
    If no services are specified, starts all services.

OPTIONS:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose logging
    -n, --dry-run       Show what would be done without executing
    -f, --force         Force restart of already running services
    -s, --status        Show status of all services
    -k, --kill          Stop all running services
    --no-cleanup        Don't stop services on script exit

SERVICES:
    knowledge-graph     Backend API service (Port 42003)
    dashboard           React dashboard UI (Port 42001)

EXAMPLES:
    $0                  # Start all services
    $0 knowledge-graph  # Start only knowledge-graph service
    $0 -f dashboard     # Force restart dashboard service
    $0 -s               # Show service status
    $0 -k               # Stop all services

LOGS:
    Service logs are written to: ${LOG_DIR}/
    PID files are stored in: ${PID_DIR}/
    Terminal logging: Automatically enabled if available for command capture

EOF
}

# Setup functions
setup_directories() {
    log_debug "Setting up directories..."
    mkdir -p "${LOG_DIR}" "${PID_DIR}"
}

setup_terminal_logging() {
    local terminal_logger="${CONTEXT_KIT_DIR}/logging-client/tkr-logger.sh"

    if [[ -f "$terminal_logger" ]]; then
        log_debug "Setting up terminal logging..."

        # Try to source terminal logging with proper variable isolation
        (
            # Run in subshell to avoid variable conflicts
            unset RED GREEN YELLOW BLUE PURPLE CYAN WHITE NC 2>/dev/null || true
            if source "$terminal_logger" 2>/dev/null; then
                # Export the functions to parent shell if possible
                export -f tkr_log tkr_info tkr_warn tkr_error tkr_debug 2>/dev/null || true
            fi
        ) && {
            log_info "Terminal logging enabled - commands will be automatically captured"
            return 0
        }

        log_debug "Failed to source terminal logging in current session (variable conflicts)"
        return 1
    else
        log_debug "Terminal logging not available at: $terminal_logger"
        return 1
    fi
}

setup_parent_shell_logging() {
    local terminal_logger="${CONTEXT_KIT_DIR}/logging-client/tkr-logger.sh"
    local enable_script="${CONTEXT_KIT_DIR}/scripts/enable-terminal-logging"
    local auto_enable_script="${CONTEXT_KIT_DIR}/scripts/auto-enable-logging"

    if [[ -f "$terminal_logger" ]]; then
        # Create a convenient enable script
        cat > "$enable_script" << EOF
#!/usr/bin/env bash
# Auto-generated helper script to enable terminal logging
# Source this script to enable terminal logging in your shell

source "${terminal_logger}"
echo "✅ Terminal logging enabled - commands will be captured and sent to dashboard"
echo "📊 View logs at: http://localhost:42001"
EOF
        chmod +x "$enable_script"

        # Create auto-enable script that tries to source automatically
        cat > "$auto_enable_script" << 'EOF'
#!/usr/bin/env bash
# Automatic terminal logging enablement for Context-Kit
# This script attempts to add logging to the current shell

CONTEXT_KIT_LOGGER="$(dirname "$0")/../logging-client/tkr-logger.sh"

if [[ -f "$CONTEXT_KIT_LOGGER" ]] && [[ "$PWD" == *"tkr-project-kit"* ]]; then
    # Attempt to source in current shell context
    if [[ "${BASH_SOURCE[0]}" != "${0}" ]] || [[ -n "$ZSH_VERSION" ]]; then
        # Script is being sourced - safe to enable logging
        source "$CONTEXT_KIT_LOGGER"
        echo "✅ Terminal logging auto-enabled"
    else
        # Script is being executed - provide instructions
        echo "To enable terminal logging, run:"
        echo "source $(dirname "$0")/enable-terminal-logging"
    fi
else
    echo "⚠️ Auto-logging only available in tkr-project-kit project directory"
fi
EOF
        chmod +x "$auto_enable_script"

        echo
        # Try to auto-enable if we're in the right context
        if [[ "$0" == *"start-all"* ]] && [[ -n "${BASH_SOURCE[0]:-$ZSH_NAME}" ]]; then
            log_info "Attempting to auto-enable terminal logging..."
            if source "$enable_script" 2>/dev/null; then
                log_success "✅ Terminal logging auto-enabled for this session!"
            else
                log_warning "Auto-enable failed - manual setup required"
            fi
        fi

        log_info "Terminal logging options:"
        echo
        echo -e "  ${GREEN}Automatic:${NC} source ${auto_enable_script}"
        echo -e "  ${GREEN}Manual:${NC}    source ${enable_script}"
        echo -e "  ${CYAN}Direct:${NC}    source ${terminal_logger}"
        echo
        echo -e "${YELLOW}Terminal logging will capture commands and send them to the dashboard${NC}"
    fi
}

# Cleanup function
cleanup() {
    if [[ "$CLEANUP_ON_EXIT" == "true" ]]; then
        log_warning "Cleanup on exit - stopping all services..."
        stop_all_services
    fi
}

# Trap cleanup on script exit
trap cleanup EXIT INT TERM

# Process detection functions
is_port_in_use() {
    local port="$1"
    if lsof -i ":${port}" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

get_service_pid() {
    local service="$1"
    local pid_file="${PID_DIR}/${service}.pid"

    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            echo "$pid"
            return 0
        else
            # Stale PID file
            rm -f "$pid_file"
        fi
    fi

    return 1
}

is_service_running() {
    local service="$1"

    # Check if service exists in SERVICES array
    if [[ -z "${SERVICES[$service]:-}" ]]; then
        return 1
    fi

    local port="${SERVICES[$service]}"

    # Check by PID file first
    if get_service_pid "$service" >/dev/null; then
        return 0
    fi

    # Check by port
    if is_port_in_use "$port"; then
        return 0
    fi

    return 1
}

# Health check functions
wait_for_service() {
    local service="$1"
    local port="${SERVICES[$service]}"
    local max_attempts=30
    local attempt=1

    log_info "Waiting for $service to be ready on port $port..."

    while [[ $attempt -le $max_attempts ]]; do
        if curl -s -o /dev/null "http://localhost:${port}/health" 2>/dev/null; then
            log_success "$service is ready!"
            return 0
        fi

        log_debug "Attempt $attempt/$max_attempts: $service not ready yet..."
        sleep 1
        ((attempt++))
    done

    log_error "$service failed to become ready after $max_attempts seconds"
    return 1
}

check_dependencies() {
    local service="$1"

    if [[ -n "${SERVICE_DEPS[$service]:-}" ]]; then
        local deps="${SERVICE_DEPS[$service]}"
        for dep in $deps; do
            if ! is_service_running "$dep"; then
                log_error "Dependency $dep is not running for $service"
                return 1
            fi
        done
    fi

    return 0
}

# Service management functions
start_knowledge_graph() {
    local service="knowledge-graph"
    local service_dir="${CONTEXT_KIT_DIR}/${service}"
    local log_file="${LOG_DIR}/${service}.log"
    local pid_file="${PID_DIR}/${service}.pid"

    # Source centralized paths and export database path for the service
    source "${CONTEXT_KIT_DIR}/scripts/paths.sh"
    get_project_paths
    export CANONICAL_DATABASE_PATH

    log_info "Starting $service service..."
    log_debug "Using database path: $CANONICAL_DATABASE_PATH"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_debug "[DRY RUN] Would start $service in $service_dir"
        return 0
    fi

    cd "$service_dir"

    # Check if package.json exists and install dependencies if needed
    if [[ -f "package.json" ]] && [[ ! -d "node_modules" ]]; then
        log_info "Installing dependencies for $service..."
        npm install >> "$log_file" 2>&1
    fi

    # Start the service
    nohup npm run dev:api >> "$log_file" 2>&1 &
    local pid=$!
    echo "$pid" > "$pid_file"

    log_debug "Started $service with PID $pid"

    # Wait for service to be ready
    if ! wait_for_service "$service"; then
        return 1
    fi

    return 0
}

start_dashboard() {
    local service="dashboard"
    local service_dir="${CONTEXT_KIT_DIR}/${service}"
    local log_file="${LOG_DIR}/${service}.log"
    local pid_file="${PID_DIR}/${service}.pid"

    log_info "Starting $service service..."

    # Check dependencies
    if ! check_dependencies "$service"; then
        return 1
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        log_debug "[DRY RUN] Would start $service in $service_dir"
        return 0
    fi

    cd "$service_dir"

    # Check if package.json exists and install dependencies if needed
    if [[ -f "package.json" ]] && [[ ! -d "node_modules" ]]; then
        log_info "Installing dependencies for $service..."
        npm install >> "$log_file" 2>&1
    fi

    # Start the service
    nohup npm run dev >> "$log_file" 2>&1 &
    local pid=$!
    echo "$pid" > "$pid_file"

    log_debug "Started $service with PID $pid"

    # Wait for service to be ready
    if ! wait_for_service "$service"; then
        return 1
    fi

    return 0
}

start_service() {
    local service="$1"

    log_debug "Attempting to start service: $service"

    # Check if service is already running
    if is_service_running "$service" && [[ "$FORCE_RESTART" == "false" ]]; then
        log_warning "$service is already running"
        return 0
    fi

    # Stop service if force restart is enabled
    if [[ "$FORCE_RESTART" == "true" ]]; then
        stop_service "$service"
    fi

    case "$service" in
        "knowledge-graph")
            start_knowledge_graph
            ;;
        "dashboard")
            start_dashboard
            ;;
        *)
            log_error "Unknown service: $service"
            return 1
            ;;
    esac
}

stop_service() {
    local service="$1"
    local pid_file="${PID_DIR}/${service}.pid"
    local port="${SERVICES[$service]}"

    log_info "Stopping $service service..."

    if [[ "$DRY_RUN" == "true" ]]; then
        log_debug "[DRY RUN] Would stop $service"
        return 0
    fi

    # Try to stop by PID first
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            log_debug "Sending TERM signal to PID $pid"
            kill "$pid" 2>/dev/null || true

            # Wait for graceful shutdown
            local attempts=10
            while [[ $attempts -gt 0 ]] && kill -0 "$pid" 2>/dev/null; do
                sleep 1
                ((attempts--))
            done

            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                log_debug "Force killing PID $pid"
                kill -9 "$pid" 2>/dev/null || true
            fi
        fi
        rm -f "$pid_file"
    fi

    # Kill any remaining processes on the port
    if is_port_in_use "$port"; then
        log_debug "Killing processes on port $port"
        lsof -ti ":${port}" | xargs -r kill -9 2>/dev/null || true
    fi

    log_success "Stopped $service service"
}

stop_all_services() {
    # Stop services in reverse dependency order
    for service in dashboard knowledge-graph; do
        if is_service_running "$service"; then
            stop_service "$service"
        fi
    done
}

show_service_status() {
    local service="$1"
    local port="${SERVICES[$service]}"

    if is_service_running "$service"; then
        local pid
        pid=$(get_service_pid "$service" || echo "unknown")
        echo -e "${GREEN}●${NC} $service (PID: $pid, Port: $port) - ${GREEN}running${NC}"

        # Check health endpoint
        if curl -s -o /dev/null "http://localhost:${port}/health" 2>/dev/null; then
            echo -e "  └─ Health check: ${GREEN}OK${NC}"
        else
            echo -e "  └─ Health check: ${YELLOW}No response${NC}"
        fi
    else
        echo -e "${RED}●${NC} $service (Port: $port) - ${RED}stopped${NC}"
    fi
}

show_all_status() {
    log_info "Context-Kit Service Status:"
    echo

    # Compatible way to iterate over associative array keys
    if [[ -n "${BASH_VERSION:-}" ]]; then
        for service in "${!SERVICES[@]}"; do
            show_service_status "$service"
        done
    else
        # zsh syntax
        for service in "${(@k)SERVICES}"; do
            show_service_status "$service"
        done
    fi

    echo
    echo "Logs directory: $LOG_DIR"
    echo "PID directory: $PID_DIR"
}

# Main execution functions
main() {
    local services_to_start=()
    local show_status=false
    local kill_services=false

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                log_info "Dry run mode enabled"
                shift
                ;;
            -f|--force)
                FORCE_RESTART=true
                shift
                ;;
            -s|--status)
                show_status=true
                shift
                ;;
            -k|--kill)
                kill_services=true
                shift
                ;;
            --no-cleanup)
                CLEANUP_ON_EXIT=false
                shift
                ;;
            knowledge-graph|dashboard)
                services_to_start+=("$1")
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    # Setup
    setup_directories

    # Setup terminal logging if available (non-fatal)
    setup_terminal_logging || true

    # Handle special modes
    if [[ "$show_status" == "true" ]]; then
        show_all_status
        exit 0
    fi

    if [[ "$kill_services" == "true" ]]; then
        stop_all_services
        exit 0
    fi

    # Default to all services if none specified
    if [[ ${#services_to_start[@]} -eq 0 ]]; then
        services_to_start=(knowledge-graph dashboard)
    fi

    log_info "Starting Context-Kit services..."
    log_debug "Services to start: ${services_to_start[*]}"

    # Start services in dependency order
    local failed_services=()

    for service in "${services_to_start[@]}"; do
        if ! start_service "$service"; then
            failed_services+=("$service")
            log_error "Failed to start $service"
        else
            log_success "Successfully started $service"
        fi
    done

    # Summary
    echo
    if [[ ${#failed_services[@]} -eq 0 ]]; then
        log_success "All services started successfully!"
        echo
        log_info "Service URLs:"
        for service in "${services_to_start[@]}"; do
            local port="${SERVICES[$service]}"
            echo "  $service: http://localhost:$port"
        done

        # Provide terminal logging setup for parent shell
        setup_parent_shell_logging
    else
        log_error "Failed to start services: ${failed_services[*]}"
        echo
        log_info "Check logs in: $LOG_DIR"
        exit 1
    fi

    # Keep script running if not in dry-run mode
    if [[ "$DRY_RUN" == "false" ]] && [[ "$CLEANUP_ON_EXIT" == "true" ]]; then
        echo
        log_info "Services are running. Press Ctrl+C to stop all services and exit."

        # Wait for interrupt
        while true; do
            sleep 1
        done
    fi
}

# Run main function
main "$@"